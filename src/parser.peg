%prefix "parser"

%value "void *"
%header {
#pragma once
#include "string_t.h"
#include "emmem.h"
#include "em_result.h"
typedef struct parser_reader_t {
  string_t * line;
  int cur;
} parser_reader_t;

em_result
parser_reader_new(parser_reader_t * out, string_t * str);

int
parser_reader_getchar(parser_reader_t * reader);
}

%source {
#include "ast.h"
#include "misc.h"
#if defined(__ESP_IDF__)
#define PCC_POOL_MIN_SIZE 256
#define PCC_BUFFER_MIN_SIZE 8
#endif
#define PCC_ERROR(auxil) fprintf(stderr, "ERROR")
#define PCC_GETCHAR(auxil) parser_reader_getchar(auxil)
#define PCC_MALLOC(auxil, size) em_malloc(size)
#define PCC_REALLOC(auxil, ptr, size) em_realloc(ptr, size)
#define PCC_FREE(auxil, ptr) em_free(ptr)

em_result
parser_reader_new(parser_reader_t * out, string_t * str) {
  out->line = str;
  out->cur = 0;
  return EM_RESULT_OK;
}
 
int
parser_reader_getchar(parser_reader_t * reader) {
  if(reader->line->length > reader->cur)
    return string_getAt(reader->line, reader->cur++);
  else
    return -1;
}

}

node_definition <- _ 'node' _ 'init' _ '[' _ ie:expression _ ']' _ n:identifier _ '=' _ e: expression _ EOL { $$ = parser_node_new(n, e, ie); }
                 / _ 'node' _ n:identifier _ 'init' _ '[' _ ie:expression _ ']' _ '=' _ e: expression _ EOL { $$ = parser_node_new(n, e, ie); }
                 / _ 'node' _ n:identifier _ '=' _ e: expression _ EOL { $$ = parser_node_new(n, e, nullptr); }
expression <- 'if' _ con:term _ 'then' _ the:term _ 'else' _ els:term { $$ = parser_expression_new_if(con, the, els); }
             / t:term { $$ = t; }

term <- l:logical { $$ = l; }
logical <- l:logical _ '&&' _ r:bitwise { $$ = parser_expression_new_dand(l, r); }
         / l:logical _ '||' _ r:bitwise { $$ = parser_expression_new_dor (l, r); }
         / b:bitwise { $$ = b; }

bitwise <- l:bitwise _ '&' _ r:comp { $$ = parser_expression_new_and(l, r); }
         / l:bitwise _ '|' _ r:comp { $$ = parser_expression_new_or (l, r); }
	 / l:bitwise _ '^' _ r:comp { $$ = parser_expression_new_xor(l, r); }
	 / c:comp { $$ = c; }

comp <- l:comp _ '='  _ r:comp2 { $$ = parser_expression_new_equal           (l, r); }
      / l:comp _ '!=' _ r:comp2 { $$ = parser_expression_new_not_equal       (l, r); }
      / c:comp2 { $$ = c; }
      
comp2 <- l:comp2 _ '<=' _ r:shift { $$ = parser_expression_new_less_or_equal   (l, r); }
       / l:comp2 _ '<'  _ r:shift { $$ = parser_expression_new_less_than       (l, r); }
       / l:comp2 _ '>=' _ r:shift { $$ = parser_expression_new_greater_or_equal(l, r); }
       / l:comp2 _ '>'  _ r:shift { $$ = parser_expression_new_greater_than    (l, r); }
       / s:shift                 { $$ = s; }

shift <- l:shift '<<' _ r:add { $$ = parser_expression_new_left_shift(l, r); }
       / l:shift '<<' _ r:add { $$ = parser_expression_new_right_shift(l, r); }
       / a:add                { $$ = a; }

add <- l:add _ '+' _ r:factor { $$ = parser_expression_new_addition(l, r); }
     / l:add _ '-' _ r:factor { $$ = parser_expression_new_subtraction(l, r); }
     / e:factor                 { $$ = e; }

factor <- l:factor _ '*' _ r:unary { $$ = parser_expression_new_multiplication(l, r); }
        / l:factor _ '/' _ r:unary { $$ = parser_expression_new_division(l, r); }
	/ l:factor _ '%' _ r:unary { $$ = parser_expression_new_modulo(l, r); }
        / e:primary                { $$ = e; }

unary <- '+' _ e:unary
       / '-' _ e:unary
       / '!' _ e:unary
       / e:primary     { $$ = e; }

primary <- '0'                       { $$ = parser_expression_new_integer(0); }
         / <[1-9][0-9]*>             { $$ = parser_expression_new_integer(atoi($1)); }
         / '0x' <[0-9]+>             { $$ = parser_expression_new_integer(strtol($2, NULL, 16)); }
         / '0' <[0-9]+>              { $$ = parser_expression_new_integer(strtol($3, NULL, 8)); }
         / '(' _ e:expression _ ')'  { $$ = e; }
	 / 'true'                    { $$ = parser_expression_true(); }
	 / 'false'                   { $$ = parser_expression_false(); }
	 / ident:lastidentifier      { $$ = parser_expression_new_last_identifier(ident); em_free(ident); }
         / ident:identifier          { $$ = parser_expression_new_identifier(ident); em_free(ident); }

_ <- [ \t]*
EOL <- '\n' / '\r\n' / '\r' / ';' / !.
lastidentifier <- <[a-zA-Z][a-zA-Z0-9_]*> '@last' { $$ = string_malloc_new($1	); }
identifier <- [a-zA-Z][a-zA-Z0-9_]*  { $$ = string_malloc_new($0); }